<!doctype html><html lang=en><head><title>漫谈加密隐私 :: KuTuGu's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" "><meta name=keywords content="密码学"><meta name=robots content="noodp"><link rel=canonical href=../../post/%E6%BC%AB%E8%B0%88%E5%8A%A0%E5%AF%86%E9%9A%90%E7%A7%81/><link rel=stylesheet href=../../assets/style.css><link rel=stylesheet id=themeColor href=../../assets/orange.css><link rel=apple-touch-icon href=../../img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=../../img/favicon/icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="漫谈加密隐私"><meta property="og:description" content=" "><meta property="og:url" content="/post/%E6%BC%AB%E8%B0%88%E5%8A%A0%E5%AF%86%E9%9A%90%E7%A7%81/"><meta property="og:site_name" content="KuTuGu's Blog"><meta property="og:image" content="/img/favicon/icon.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-10-03 08:57:49 +0800 +0800"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=../../><div class=logo>Main</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=../../about>About</a></li><li><a href=https://github.com/KuTuGu>Github</a></li><li><a href=../../resume_en>Resume_en</a></li><li><a href=../../resume_zh>Resume_zh</a></li><li><a href=https://twitter.com/kutugu1>Twitter</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=../../about>About</a></li><li><a href=https://github.com/KuTuGu>Github</a></li><li><a href=../../resume_en>Resume_en</a></li><li><a href=../../resume_zh>Resume_zh</a></li><li><a href=https://twitter.com/kutugu1>Twitter</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=../../post/%E6%BC%AB%E8%B0%88%E5%8A%A0%E5%AF%86%E9%9A%90%E7%A7%81/>漫谈加密隐私</a></h1><div class=post-meta><span class=post-date>2021-10-03</span>
<span class=post-author>:: KuTuGu</span></div><span class=post-tags>#<a href=../../tags/%E5%8C%BA%E5%9D%97%E9%93%BE/>区块链</a>&nbsp;</span><div class=post-content><div><h1 id=漫谈加密隐私>漫谈加密隐私<a href=#漫谈加密隐私 class=hanchor arialabel=Anchor>&#8983;</a></h1><h2 id=概述>概述<a href=#概述 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>加密</strong>，即将明文信息改变为难以理解的密文内容，使之不可读。只有拥有解密方法的对象，才能将密文还原为明文。</p><p>从古至今，密码学已有数千年的历史。从早期的古典密码，到近现代密码，再到未来的量子密码。加密手段也由早期简单的代替和置换，进化到现代数学方法，再到未来的量子性质。</p><p>本篇文章无意讲述整个密码学的发展史，而是聚焦于现代计算机应用中所涉及的加密方法和原理，漫谈 <strong>Web2</strong> 和 <strong>区块链</strong> 涉猎的加密内容。</p><p>个人能力所限，如有缺漏错误之处，望指正。</p><p>PS：</p><ul><li><a href=https://en.wikipedia.org/wiki/The_Code_Book>https://en.wikipedia.org/wiki/The_Code_Book</a></li></ul><h2 id=现代密码学>现代密码学<a href=#现代密码学 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=原理>原理<a href=#原理 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>近现代以来，随着数学方法和的计算机科学蓬勃发展，为加密技术提供了新的概念和工具。一个重要的标志是香农的<a href=https://en.wikipedia.org/wiki/Communication_Theory_of_Secrecy_Systems>《保密系统通信理论》</a>，将传统密码学推向了基于信息论的科学轨道。</p><p>近现代加密技术经历了无数次迭代，大体上可分为两类：<strong>对称密钥算法</strong>和<strong>非对称密钥算法</strong>。</p><p>对称密钥，即发送方和接收方采用<strong>相同密钥</strong>对明文进行加解密；非对称密钥则相反，它有两个公钥和私钥，分别用于加密、解密。</p><p>对称密钥可以任意选取，只要足够安全；而非对称密钥则是通过一系列<a href=https://en.wikipedia.org/wiki/P_versus_NP_problem>NP问题</a>生成的。如RSA利用大质数性质，ECC（椭圆曲线）利用离散对数问题。</p><p>简单来讲，P问题是在多项式时间内可以解出的；NP问题是在多项式时间内可以验证一个解的；P = NP意味着NP问题也是在多项式时间内可以解出的，而非对称密钥就建立在P != NP的基础上。</p><p>以RSA为例，一个大致流程可以理解如下：</p><ul><li>NP问题 &ndash; RSA算法大质数分解；</li><li>一个特解 &ndash; 两个因子和大质数，利用因子生成公钥、私钥；</li><li>两个精致算法 &ndash; 可以利用<strong>公钥加密、私钥解密</strong> 或 <strong>私钥签名、公钥认证</strong>；</li><li>黑客攻击 &ndash; 暴力分解大质数，拿到因子和私钥</li></ul><h3 id=弊端>弊端<a href=#弊端 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>对于对称密钥加密来说，缺点在于密钥的分发，如何保证安全地分发到发送方和接收方手上；</li><li>对于非对称密钥加密来说，缺点在于加解密的速度，如RSA算法每次加解密需要进行指数和取模运算，而对称密钥只需要做按位运算。</li></ul><p>所以常见应用场景是结合两种方式，利用非对称密钥加密分发对称密钥，解决上述痛点问题。</p><h2 id=web2>Web2<a href=#web2 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=https>HTTPS<a href=#https class=hanchor arialabel=Anchor>&#8983;</a></h3><p>在传统的Web2服务中，一个最常见的加密就是TLS加密，HTTPS = HTTP + TLS。</p><p>HTTP是明文传输的，这意味着在网络中所有中间节点都可以看到传输信息。为了保护敏感信息，我们采用TLS加密，使明文内容只对服务端可见。</p><p>TLS的一个大致流程如下：</p><pre tabindex=0><code>1. 完成TCP握手后，客户端发起TLS请求，携带公开随机数、支持的对称加密方法、TLS版本、域名等信息；
2. 服务端返回证书、公开随机数、支持的对称加密方法；
3. 客户端验证证书有效性，解出服务端公钥，发送一个加密随机数；
4. 通过三个随机数生成对称密钥，加密之后的通信内容
</code></pre><p>还有面对银行等安全场景的双向验证，服务器端还需验证客户端证书，大致流程也类似。</p><p>整个过程有一个问题：要如何信任服务端返回的证书（公钥），而不是中间人攻击替换后的？</p><p>在网络的黑暗丛林中，我们需要一个权威机构（CA）来认证，这里就涉及到非对称密钥的另一个用途：<strong>私钥签名、公钥认证</strong>。</p><p>CA通过它的私钥来证明证书的有效性，那我们如何确保正确拿到CA的公钥来认证呢？答案是它内置在操作系统或浏览器中，我们也可以手动增删。</p><p>最后为了保护这些CA的私钥不泄漏和降低泄漏后的影响面，我们把这些CA按层级划分，形成一个CA证书的信任链。</p><h3 id=signal>Signal<a href=#signal class=hanchor arialabel=Anchor>&#8983;</a></h3><p>在C2C的场景中，我们也需要端到端加密，不过是服务端变成了另一个客户端，但我们不希望中间服务器有能力窃听通信内容。</p><p>你可能会有疑问：既然是C2C，那为什么我们还需要服务器？原因有很多：</p><ul><li>公钥的分发，中间服务器在这里相当于CA权威机构的角色，预防中间人攻击</li><li>NAT穿透，由于IPv4的局限性，我们大部分的地址是动态的内网地址，它是无法作为公网IP进行通信的</li><li>信息缓存，历史信息保存 或 一方离线时也需要由服务器缓存相关信息，等该端上线时再进行分发</li><li>信息转发，群组聊天中，需要中间服务器转发给其他成员，发送端只需发送一次到服务端</li><li>垃圾信息过滤，中间服务器采用好友关系等机制限制垃圾信息洪流</li></ul><p>PS：</p><ul><li><a href=https://iangeli.com/2019/04/25/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E5%8A%A0%E5%AF%86%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AESignal-protocol-%E5%AD%A6%E4%B9%A0.html>https://iangeli.com/2019/04/25/%E7%AB%AF%E5%AF%B9%E7%AB%AF%E5%8A%A0%E5%AF%86%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AESignal-protocol-%E5%AD%A6%E4%B9%A0.html</a></li></ul><h2 id=区块链>区块链<a href=#区块链 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=加密货币>加密货币<a href=#加密货币 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>区块链上的虚拟货币也被称为 <strong>加密货币</strong>。加密属性从何而来？</p><p>个人所认为的加密不只是所谓的<strong>地址代替实名</strong>，而是更有意义的<strong>隐匿</strong>：<strong>隐匿资产</strong>、<strong>隐匿地址关系</strong>、<strong>隐匿交易细节</strong>。</p><p>很遗憾，目前主流的区块链本身并没有这一功能，它也不算是必需品，因此后面在区块链协议之上繁衍出了各种应用级产品：<strong>隐私币</strong>、<strong>隐私合约</strong>，最后甚至是专门面向隐私功能的<strong>隐私链</strong>。</p><p>在了解这些产品前，我们先来学习下区块链本身的隐匿性。如<a href=https://zhuanlan.zhihu.com/p/57272282>比特币和以太坊的帐户模型</a></p><p>小结下就是：区块链本身的隐匿性聊胜于无，基于UTXO模型的<a href=https://happypeter.github.io/binfo/p2sh>P2SH类型</a>交易，有一定的隐匿性，可以暂时 <strong>隐匿接收者（地址关系）</strong>，当花费这笔代币时，接收者还是会暴露。</p><h3 id=零知识证明>零知识证明<a href=#零知识证明 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>在学习下面的加密原理之前，先要理解一个不可或缺的知识点 &ndash; <strong>零知识证明</strong>。理论概念可以参考我之前的一篇<a href=https://kutugu.eth.limo/D19E5932-4374-48C2-87F7-CC053FB1FBB2>小结</a>，具体执行流程推荐阅读<a href=https://github.com/iden3/snarkjs#guide>官方文档</a>。</p><p>有了上面的预备知识，接下来我将带大家简单剖析各个具体的隐私应用，来了解其中的加密原理。</p><h3 id=隐私币>隐私币<a href=#隐私币 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>隐私币一般指基于比特链协议的硬分叉的区块链，一条链即一个币，也基于比特币的UTXO模型。比特链生态是没有智能合约应用概念的，我将这些功能链也视为一个个应用级的产品。</p><p><strong>Dash</strong></p><p>Dash采用<strong>混币系统</strong>来实现一定程度的隐私。它在比特链的基础上进行了扩展，建立了一个由主节点和矿工组成的双层网络：</p><ul><li>第一层网络中，矿工节点通过POW共识来计帐和保护网络安全;</li><li>第二层网络实现混币相关的功能，主节点用于执行隐私交易、即时交易和网络管理。 节点将多方交易混合在一起再对外发送，打乱地址关系的映射。</li></ul><p>该方法只能实现对地址关系的隐匿，甚至在参与方较少、金额数目特殊的情况下，地址关系也无所遁形。</p><p><strong>Monero</strong></p><ul><li><a href=https://learnblockchain.cn/index.php/article/1123>https://learnblockchain.cn/index.php/article/1123</a></li></ul><p><strong>Zcash</strong></p><p>Zcash的隐藏原理基于<strong>单向哈希</strong>和<strong>零知识证明</strong>：</p><ul><li>要隐藏一个信息很简单，一开始我们就提到了各种加密方法；</li><li>要隐藏一个不需要恢复的信息更简单，一个单向的哈希就可以做到。</li></ul><p>既然我们不想让任何人查看交易细节，那我们就将这些全部做哈希处理再存储到共识节点，不就可以了？</p><p>当然共识节点也不傻，你提交一条哈希给我，我如何知道哈希所代表的内容是否准确？这时便需要零知识证明发挥作用了。另外为了防止重放攻击，还需要对证明进行签名。</p><p>具体细节推荐阅读：https://www.8btc.com/article/526391</p><p>下面我们梳理下整个Zcash的交易流程，与UTXO模型大体类似（UTXO模型的交易流程由于有<strong>P2PKH</strong>、<strong>P2SH</strong>等各种类型，就不再赘述）。</p><p>首先Zcash中，UTXO模型（note）结构体如下：</p><ul><li>持有者的公钥: a_pk；</li><li>数额: value，简称 v；</li><li>随机数: r；</li><li>随机数hash：rho，即HASH（r）</li></ul><pre tabindex=0><code>1. A -→ B 转账，多个input note -→ 多个output note（可能有剩余返还给A）
2. A解析并发布这些input note（hash）的废弃声明，共识节点在nullifier列表中验证，防止双花；
3. 同时发送新生成的output note（hash）声明；还要发送零知识证明和签名，证明A发送的这些hash声明对应的交易内容是完全正确的；
4. A将属于B的output note（detail）发送给B
</code></pre><p>注意第三步，由于链上存储的都是hash，B是不知道note细节的，但是在花费这些note时，B需要发布基于rho的废弃声明，所以A需要发送具体内容给B。</p><p>那么怎么在不安全的网络安全地发送明文内容呢？</p><ul><li><a href=https://learnblockchain.cn/2019/07/28/zcash-sprout>https://learnblockchain.cn/2019/07/28/zcash-sprout</a>（Zcash的具体加密方案）</li><li><a href=https://github.com/zcash/zips/blob/main/protocol/protocol.pdf>https://github.com/zcash/zips/blob/main/protocol/protocol.pdf</a>（Zcash白皮书）</li></ul><h3 id=隐私合约>隐私合约<a href=#隐私合约 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>Tornado Cash</strong></p><p>Tornado是基于以太坊的混币应用，也是只能打乱地址的映射关系。</p><p>不过它有意思的地方在于利用零知识证明，实现了验证逻辑。整体流程如下：</p><pre tabindex=0><code>1. 存款前生成随机数secret和nullifier，nullifier -→ nullifierHash，secret + nullifier -→ commitment，tornado note = nullifier + secret；
2. 存款时，提交commitment，没有冲突就会将commitment插入到合约地址维护的Merkle树中；
3. 取款前，输入凭证note，解析出nullifierHash和commitment，并从Merkle树中获取commitment的链路；
4. 取款时，输入取款地址，与secret、nullifier和其他证明一起生成零知识证明，以供验证
</code></pre><p>PS：Tornado的中继服务解决了支付困境问题，提款时交易费由中继者支付，同时扣除提款总额的一部分作为服务费。</p><ul><li><a href=https://docs.tornado.cash/general/readme>https://docs.tornado.cash/general/readme</a>（官方文档）</li><li><a href=https://github.com/tornadocash/tornado-core>https://github.com/tornadocash/tornado-core</a>（源码地址）</li><li><a href=https://zhuanlan.zhihu.com/p/94979076>https://zhuanlan.zhihu.com/p/94979076</a>（源码解读）</li></ul><p><strong>Automata Network</strong></p><p>Automata Network的定位是应用中间件，支持多链协议，它的隐私功能致力于提供一套安全可信的运行环境。</p><p>不过个人理解，像预言机一样，它提供的只是链下隐私，进行相关的证明验证，得到结果后再通知链上DAPP。</p><p>具体实现原理是通过 <strong>TEE可信执行环境</strong> 与 <strong>Oblivious RAM</strong> 算法，创建一个本地数据无法被第三方（甚至本地进程）访问的安全空间。</p><p>TEE的具体实现通过Intel的SGX，它保证了<strong>数据隐私</strong>和<strong>远程证明</strong>。保证数据隐私很好理解，远程证明是指向其他第三方提供相关远程安全证明：</p><ul><li>硬件检查：硬件制造商会有相关私钥签名，可以通过公钥进行验证；</li><li>软件检查：生成软件代码哈希，进行校验</li></ul><p>那TEE有什么作用呢？前面我们提到过完全加密很好处理，一个单向哈希即可，但难的是我们需要同时让矿工节点知道交易内容的准确性。</p><p>一种解决方案是零知识证明，但它的生成很复杂；另一种就是TEE。TEE提供了一个可信环境，除了特定的一组接口，无法通过其他方法读写数据。</p><p>通过这个特点，我们可以在其中进行任何隐私验证。如通过编写TA程序（Trusted Application），我们可以把矿工验证逻辑放到TEE中，矿工只需要知道一个验证结果。同时在不同节点远程校验，从而形成共识。</p><p>当然TEE和零知识证明也不是互斥的，我们甚至可以在TEE之上使用零知识证明。</p><p>只是对数据加密还不够，通过侧信道攻击（side channel attack）也可能被盗取敏感信息：由于<a href=https://en.wikipedia.org/wiki/Memory_access_pattern>数据访问模式</a>，当频繁读写某些数据时，攻击者可以定位到数据储存位置，甚至推测出敏感信息。这时便需要 <strong>Oblivious RAM</strong> 算法来隐藏真实访问。</p><p>算法原理也很好理解，每次读写数据时，不仅仅读写所需的数据，同时读写其他数据进行混淆</p><h3 id=隐私链>隐私链<a href=#隐私链 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><strong>Secret Network</strong></p><p>Secret Network是基于Cosmos的一条支持智能合约的异构链，它利用TEE实现了对隐私的支持。</p><p>一个大致流程如下：</p><pre tabindex=0><code>1. 开发人员编写智能合约并部署，合约加密发送到矿工节点TEE中；
2. 节点在TEE中解密验证交易内容，提出一个包含加密输出和更新加密状态的区块；
3. 2/3 的验证者就加密输出和状态达成共识，存储合约代码到TEE中；
4. 用户向智能合约发起交易，包括加密的数据输入，流程同上；
</code></pre><p>学习 Secret Network 合约，首先要了解Rust语言，这里推荐 <a href=https://course.rs/>Rust中文圣经</a>。</p><p>学习 Secret Network 前，需要了解 CosmWasm，前者建立在后者的基础上。CosmWasm 和 Solidity 也有很多不同需要了解：https://docs.cosmwasm.com/docs/1.0/</p><p>对 Secret Network 的学习，推荐先阅读<a href=https://build.scrt.network/>官方文档</a>，其提供了许多学习资源。</p><p><a href=https://github.com/scrtlabs/testnet/blob/master/pulsar-2/details.md>测试网络</a></p><p>开发入门，推荐<a href=https://learn.figment.io/protocols/secret>figment教程</a>。</p><p>里面有很多细节，如：</p><ul><li>编译不成功，利用docker编译：<a href=https://learn.figment.io/tutorials/deploy-your-own-secret-nft#compile-the-contract>https://learn.figment.io/tutorials/deploy-your-own-secret-nft#compile-the-contract</a></li><li>调用传参，uint128类型对应js的string类型：<a href=https://learn.figment.io/tutorials/creating-a-secret-contract-from-scratch#a-note-about-data-types-between-the-client-and-contract>https://learn.figment.io/tutorials/creating-a-secret-contract-from-scratch#a-note-about-data-types-between-the-client-and-contract</a></li><li>Query和Handle的花费和安全如何取舍：<a href=https://learn.figment.io/tutorials/create-your-first-secret-nft#querying-the-contract>https://learn.figment.io/tutorials/create-your-first-secret-nft#querying-the-contract</a></li></ul><p>最后提下ERC20、ERC721规范的兼容实现：</p><p><a href=https://build.scrt.network/dev/tutorials.html#references-for-secret-contracts>https://build.scrt.network/dev/tutorials.html#references-for-secret-contracts</a></p><p>PS：这个只是对规范的兼容，没有实现支付、白名单等功能。下面这个库增加了这些功能：</p><p><a href=https://github.com/luminaryphi/secret-random-minting-snip721-impl>https://github.com/luminaryphi/secret-random-minting-snip721-impl</a></p><p><strong>Oasis Network</strong></p><p>Oasis Network是一条支持智能合约的区块链。它采用<strong>模块化</strong>设计，提供了对<strong>隐私</strong>、<strong>私有链</strong>的支持。</p><p>Oasis 由两层网络构成：共识层和ParaTime层。你可以将其理解为二层的架构设计，类似于以太坊L2的多链，在ParaTime层中执行智能合约的计算。整体架构图如下所示：</p><p><img src="https://images.mirror-media.xyz/publication-images/AmJWtxgXfYWQH3dnI7btU.png?height=1004&amp;width=1256" alt=Oasis网络架构></p><p>前面提到的模块化就是指ParaTime的实现非常灵活，支持自由组合：</p><ul><li>在代码规范方面可以支持 EVM 或 WASM；</li><li>在加密隐私方面可以直接裸奔，或选择TEE、零知识证明等加密；</li><li>在公私链方面可以设计为有无许可系统</li></ul><p>推荐阅读：</p><ul><li><a href=https://www.chaincatcher.com/article/2072039>https://www.chaincatcher.com/article/2072039</a>（项目介绍）</li><li><a href=https://docsend.com/view/6sui2cag4p45ea45>https://docsend.com/view/6sui2cag4p45ea45</a>（白皮书）</li></ul><h3 id=隐私项目>隐私项目<a href=#隐私项目 class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li><a href=https://www.chaincatcher.com/article/2070927>https://www.chaincatcher.com/article/2070927</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>阅读其它文章</span><hr></div><div class=pagination__buttons><span class="button next"><a href=../../post/%E8%B7%A8%E9%93%BE--%E9%93%BE%E6%8E%A5%E4%BF%A1%E6%81%AF%E5%AD%A4%E5%B2%9B%E7%9A%84%E6%A1%A5%E6%A2%81/><span class=button__text>跨链 -- 链接信息孤岛的桥梁</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=../../assets/main.js></script>
<script src=../../assets/prism.js></script>
<script src=../../assets/colorful.js></script></div></body></html>