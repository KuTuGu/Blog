<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>前端框架 on KuTuGu's Blog</title><link>/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</link><description>Recent content in 前端框架 on KuTuGu's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Wed, 26 Aug 2020 23:26:03 +0800</lastBuildDate><atom:link href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/index.xml" rel="self" type="application/rss+xml"/><item><title>React新版本为什么要移除掉一些生命周期</title><link>/post/react%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A7%BB%E9%99%A4%E6%8E%89%E4%B8%80%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link><pubDate>Wed, 26 Aug 2020 23:26:03 +0800</pubDate><guid>/post/react%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A7%BB%E9%99%A4%E6%8E%89%E4%B8%80%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid><description>React新版本为什么要移除掉一些生命周期？ 从上图新版本React的生命周期来看，React废弃了以下三种生命周期钩子：
componentWillMount componentWillReceiveProps componentWillUpdate 下面我们来逐一分析它们被废弃的原因：
componentWillReceiveProps 此方法将会被getDerivedStateFromProps这一静态方法取代，通过返回一个对象来表示新的state。
看似并无区别，但使用getDerivedStateFromProps的原因在于对API的进一步解耦。 此方法是静态的，所以无法获取或者执行实例上的其他副作用函数，只专注于根据当前的nextProps来更新组件的state。
原来的componentWillReceiveProps函数内，this上的其余副作用函数可以在componentDidUpdate中进行。
一方面，React通过API规范来约束开发者，强调代码书写的规范性。 另一方面，通过将状态变化和副作用分离到Fiber架构的Reconciliation和Commit两个阶段，优化性能（详情见下文）。
componentWillMount 很多开发者喜欢在componentWillMount中获取异步数据，希望可以提早进行异步请求，尽量避免白屏。首先，这一想法不无道理，分两种情况考虑：
立即获取数据，在第一次render之前处理完成，避免白屏 异步获取数据，第二次render进行有效绘制，与componentDidMount相比白屏时间缩短 当然，官方对于这一解释是：componentWillMount、render 和 componentDidMount 方法虽然存在调用先后顺序。 但在大多数情况下，几乎都是在很短的时间内先后执行完毕，几乎不会对用户体验产生影响。
看样子在componentWillMount似乎并无不妥之处，反而还可能会优化效率，为什么会被废除呢？主要原因有以下几点：
对于服务器渲染（ssr），在componentWillMount内获取数据可以保证返回的页面是最终页面，但存在一个问题：客户端渲染时会再次请求，会浪费IO资源。 对于服务器渲染（ssr），在componentWillMount中绑定事件，但由于并没有后续的生命周期，导致资源无法释放，可能产生内存泄露。 客户端渲染也有可能产生上面两个问题，在Fiber架构中，componentWillMount所在的Reconciliation阶段可能被多次打断，可能产生多次网络请求或多次事件监听（详情见下文）。 componentWillUpdate componentWillUpdate也是如此：
componentWillUpdate可能被多次打断，在这个钩子获取更新前的视图情况或执行副作用都不妥 getSnapshotBeforeUpdate是真正在视图变更前调用的，获取到组件状态信息更加可靠； 另一方面getSnapshotBeforeUpdate的返回结果可直接作为参数传入componentDidUpdate中。 Fiber核心架构 从上面三个生命周期的移除都可以看到Fiber架构的身影，下面我们就来深入了解下：
React新版本的到来，与之相应的是核心架构的替换和异步渲染概念的引入。
React框架的视图更新取决于virtual dom和diff算法，找到变化之后再将新的virtual dom渲染到不同视图(如android、pc)，这一通用的过程称为Reconciler。
旧版本的React使用的是Stack Reconciler，新版本采用的是Fiber Reconciler，因为其中任务调度处理的最小单元为Fiber数据结构：
// Fiber 基于链表结构，拥有一个个指针，指向它的父节点子节点和兄弟节点。 // 在 diff 的过程中，依照节点的链接关系进行遍历 Fiber = { &amp;#39;tag&amp;#39; // 标记任务节点类型 &amp;#39;return&amp;#39; // 父节点 &amp;#39;child&amp;#39; // 子节点 &amp;#39;sibling&amp;#39; // 兄弟节点 &amp;#39;alternate&amp;#39; // 变化记录 // ..... }; 两者的主要区别在于： 相比于Stack Reconciler的递归调用渲染，虽然diff算法被React优化为O(n)复杂度，但对于特别庞大的dom树来说，递归调用依旧会消耗特别长的时间，在这期间任何交互都会被阻塞。</description><content>&lt;h1 id="react新版本为什么要移除掉一些生命周期">React新版本为什么要移除掉一些生命周期？&lt;/h1>
&lt;p>从上图新版本React的生命周期来看，React废弃了以下三种生命周期钩子：&lt;/p>
&lt;ul>
&lt;li>&lt;code>componentWillMount&lt;/code>&lt;/li>
&lt;li>&lt;code>componentWillReceiveProps&lt;/code>&lt;/li>
&lt;li>&lt;code>componentWillUpdate&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>下面我们来逐一分析它们被废弃的原因：&lt;/p>
&lt;h2 id="componentwillreceiveprops">componentWillReceiveProps&lt;/h2>
&lt;p>此方法将会被&lt;code>getDerivedStateFromProps&lt;/code>这一静态方法取代，通过返回一个对象来表示新的state。&lt;/p>
&lt;p>看似并无区别，但使用&lt;code>getDerivedStateFromProps&lt;/code>的原因在于对API的进一步解耦。 &lt;br>
此方法是静态的，所以无法获取或者执行实例上的其他副作用函数，只专注于根据当前的&lt;code>nextProps&lt;/code>来更新组件的&lt;code>state&lt;/code>。&lt;/p>
&lt;p>原来的&lt;code>componentWillReceiveProps&lt;/code>函数内，this上的其余副作用函数可以在&lt;code>componentDidUpdate&lt;/code>中进行。&lt;/p>
&lt;p>一方面，React通过API规范来约束开发者，强调代码书写的&lt;code>规范性&lt;/code>。 &lt;br>
另一方面，通过将&lt;code>状态变化&lt;/code>和&lt;code>副作用&lt;/code>分离到&lt;code>Fiber&lt;/code>架构的&lt;code>Reconciliation&lt;/code>和&lt;code>Commit&lt;/code>两个阶段，优化性能（详情见下文）。&lt;/p>
&lt;h2 id="componentwillmount">componentWillMount&lt;/h2>
&lt;p>很多开发者喜欢在&lt;code>componentWillMount&lt;/code>中获取异步数据，希望可以提早进行异步请求，尽量避免白屏。首先，这一想法不无道理，分两种情况考虑：&lt;/p>
&lt;ul>
&lt;li>立即获取数据，在第一次render之前处理完成，避免白屏&lt;/li>
&lt;li>异步获取数据，第二次render进行有效绘制，与&lt;code>componentDidMount&lt;/code>相比白屏时间缩短&lt;/li>
&lt;/ul>
&lt;p>当然，官方对于这一解释是：&lt;code>componentWillMount&lt;/code>、&lt;code>render&lt;/code> 和 &lt;code>componentDidMount&lt;/code> 方法虽然存在调用先后顺序。 &lt;br>
但在大多数情况下，几乎都是在很短的时间内先后执行完毕，几乎不会对用户体验产生影响。&lt;/p>
&lt;p>看样子在&lt;code>componentWillMount&lt;/code>似乎并无不妥之处，反而还可能会优化效率，为什么会被废除呢？主要原因有以下几点：&lt;/p>
&lt;ul>
&lt;li>对于服务器渲染（&lt;code>ssr&lt;/code>），在&lt;code>componentWillMount&lt;/code>内获取数据可以保证返回的页面是最终页面，但存在一个问题：客户端渲染时会再次请求，会&lt;code>浪费IO资源&lt;/code>。&lt;/li>
&lt;li>对于服务器渲染（&lt;code>ssr&lt;/code>），在&lt;code>componentWillMount&lt;/code>中绑定事件，但由于并没有后续的生命周期，导致资源无法释放，可能产生&lt;code>内存泄露&lt;/code>。&lt;/li>
&lt;li>客户端渲染也有可能产生上面两个问题，在&lt;code>Fiber&lt;/code>架构中，&lt;code>componentWillMount&lt;/code>所在的&lt;code>Reconciliation&lt;/code>阶段可能被多次打断，可能产生多次网络请求或多次事件监听（详情见下文）。&lt;/li>
&lt;/ul>
&lt;h2 id="componentwillupdate">componentWillUpdate&lt;/h2>
&lt;p>&lt;code>componentWillUpdate&lt;/code>也是如此：&lt;/p>
&lt;ul>
&lt;li>&lt;code>componentWillUpdate&lt;/code>可能被多次打断，在这个钩子获取&lt;code>更新前的视图情况&lt;/code>或执行副作用都不妥&lt;/li>
&lt;li>&lt;code>getSnapshotBeforeUpdate&lt;/code>是真正在视图变更前调用的，获取到组件状态信息更加可靠； &lt;br>
另一方面&lt;code>getSnapshotBeforeUpdate&lt;/code>的返回结果可直接作为参数传入&lt;code>componentDidUpdate&lt;/code>中。&lt;/li>
&lt;/ul>
&lt;h2 id="fiber核心架构">Fiber核心架构&lt;/h2>
&lt;p>从上面三个生命周期的移除都可以看到&lt;code>Fiber&lt;/code>架构的身影，下面我们就来深入了解下：&lt;/p>
&lt;p>React新版本的到来，与之相应的是&lt;code>核心架构&lt;/code>的替换和&lt;code>异步渲染&lt;/code>概念的引入。&lt;/p>
&lt;p>React框架的视图更新取决于&lt;code>virtual dom&lt;/code>和&lt;a href="https://juejin.im/post/5cb5b4926fb9a068b52fb823">diff算法&lt;/a>，找到变化之后再将新的&lt;code>virtual dom&lt;/code>渲染到不同视图(如android、pc)，这一通用的过程称为&lt;code>Reconciler&lt;/code>。&lt;/p>
&lt;p>旧版本的React使用的是&lt;code>Stack Reconciler&lt;/code>，新版本采用的是&lt;code>Fiber Reconciler&lt;/code>，因为其中任务调度处理的最小单元为&lt;code>Fiber&lt;/code>数据结构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Fiber 基于链表结构，拥有一个个指针，指向它的父节点子节点和兄弟节点。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在 diff 的过程中，依照节点的链接关系进行遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">Fiber&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;tag&amp;#39;&lt;/span> &lt;span style="color:#75715e">// 标记任务节点类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#39;return&amp;#39;&lt;/span> &lt;span style="color:#75715e">// 父节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#39;child&amp;#39;&lt;/span> &lt;span style="color:#75715e">// 子节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#39;sibling&amp;#39;&lt;/span> &lt;span style="color:#75715e">// 兄弟节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#39;alternate&amp;#39;&lt;/span> &lt;span style="color:#75715e">// 变化记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// .....
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>两者的主要区别在于：
相比于&lt;code>Stack Reconciler&lt;/code>的递归调用渲染，虽然diff算法被React优化为&lt;code>O(n)&lt;/code>复杂度，但对于特别庞大的dom树来说，递归调用依旧会消耗特别长的时间，在这期间任何交互都会被阻塞。&lt;/p>
&lt;p>&lt;code>Fiber Reconciler&lt;/code>引入了异步渲染的概念，虽然也是根据Fiber数据结构进行链式处理，但可以将其切割为一个个小任务，异步进行处理，避免堵塞高优先级的交互等事件：&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Fiber&lt;/code>的出现把&lt;code>Reconciler&lt;/code>的过程拆分成了一个个的小任务，并在完成了小任务之后暂停执行，检查是否有&lt;code>高优先级&lt;/code>需要更新的内容和需要响应的事件，做出相应的处理后再继续执行。&lt;/p>
&lt;p>&lt;code>Fiber&lt;/code>还会为不同的任务设置不同的优先级：&lt;/p>
&lt;ul>
&lt;li>高优先级任务是需要马上展示到页面上的，如&lt;code>用户交互&lt;/code>、&lt;code>动画&lt;/code>等。&lt;/li>
&lt;li>低优先级的任务如&lt;code>网络请求&lt;/code>、&lt;code>state变更&lt;/code>等，可以在后面进行延迟处理。 &lt;br>
当然React会为其指定&lt;a href="https://www.zhihu.com/question/405268183">阈值&lt;/a>，避免长期被高优先级打断。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一些优先级划分参考如下：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Synchronous&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#75715e">// 同步任务，优先级最高
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Task&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#75715e">// 当前调度正执行的任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Animation&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#75715e">// 动画
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">High&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#75715e">// 高优先级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Low&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#75715e">// 低优先级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Offscreen&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#75715e">// 当前屏幕外的更新，优先级最低
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;p>&lt;img src="../../img/react/fiber-phase.png" alt="Fiber阶段">&lt;/p>
&lt;p>前面说了&lt;code>Fiber&lt;/code>算法中更新是分阶段的，首先是&lt;code>Reconciliation&lt;/code>阶段，这个阶段在diff前后&lt;code>virtual dom&lt;/code>树的差异，耗时过长，可以打断；然后是&lt;code>Commit&lt;/code>的阶段，这个阶段将一直把更新渲染到页面上。&lt;/p>
&lt;p>&lt;code>Reconciliation&lt;/code>阶段有那些生命周期呢？没错，废除的三个生命周期赫然在列：&lt;/p>
&lt;ul>
&lt;li>&lt;code>componentWillMount&lt;/code>&lt;/li>
&lt;li>&lt;code>componentWillReceiveProps&lt;/code>&lt;/li>
&lt;li>&lt;code>componentWillUpdate&lt;/code>&lt;/li>
&lt;li>&lt;code>shouldComponentUpdate&lt;/code>，纯函数不会移除&lt;/li>
&lt;/ul>
&lt;h3 id="推荐阅读">推荐阅读&lt;/h3>
&lt;p>&lt;a href="https://juejin.im/post/5e1e9f33f265da3e2c247176#heading-16">零代码深入浅出React并发模式，带你理解React Fiber架构&lt;/a>&lt;/p>
&lt;h2 id="事件循环----fiber架构的实现原理">事件循环 &amp;ndash; Fiber架构的实现原理&lt;/h2>
&lt;p>&lt;code>Fiber&lt;/code>架构的&lt;code>异步渲染&lt;/code>依赖的是浏览器底层的&lt;code>事件循环&lt;/code>。&lt;/p>
&lt;p>我们知道浏览器的持续渲染页面依赖的就是事件循环机制，当页面文件解析后、脚本执行，会形成各种队列，之后就开始了页面的事件循环：&lt;/p>
&lt;ul>
&lt;li>各种宏任务队列（取一任务） =&amp;gt; 微任务队列（全部执行） =&amp;gt; 渲染（可能） =&amp;gt; 计算空闲时间&lt;/li>
&lt;/ul>
&lt;p>上述循环基本完成在一帧（和&lt;code>浏览器&lt;/code>刷新率有关，一般为60HZ或者更高）内，渲染阶段根据是否有足够时间选择是否执行。&lt;/p>
&lt;p>为了保证页面的流畅度，渲染帧数要保证在每秒60左右(和刷新率无关，当然高刷新率的渲染帧数一般会更高)&lt;/p>
&lt;p>由上述可知，这个渲染阶段是不可控的。而之前使用&lt;code>setTimeInterval&lt;/code>来绘制动画：&lt;/p>
&lt;ul>
&lt;li>一方面可能被其他任务堵塞，造成&lt;code>延迟&lt;/code>，或者在浏览器下次重绘之前调用多次，导致&lt;code>掉帧&lt;/code>；&lt;/li>
&lt;li>另一方面固定的间隔在&lt;code>不同刷新率&lt;/code>设备的适配上也有一定问题。&lt;/li>
&lt;/ul>
&lt;p>于是浏览器暴露了一些接口来细粒化地控制事件循环的绘制：&lt;code>requestAnimationFrame&lt;/code>、&lt;code>requestIdleCallback&lt;/code>。&lt;/p>
&lt;p>&lt;img src="../../img/eventLoop/frame.jpg" alt="frame">&lt;/p>
&lt;h3 id="requestanimationframe">requestAnimationFrame&lt;/h3>
&lt;p>简单来说，&lt;code>requestAnimationFrame&lt;/code>内的回调函数会在浏览器下一次重绘之前执行，完美地解决了上述&lt;code>setTimeInterval&lt;/code>的问题，而且如果标签页被隐藏，回调也会被暂停调用以提升性能和电池寿命。&lt;/p>
&lt;p>具体应用时需要注意两点：&lt;/p>
&lt;ul>
&lt;li>&lt;code>requestAnimationFrame&lt;/code>只会要求浏览器在&lt;code>下一次&lt;/code>重绘之前调用指定的回调函数，连续需要递归&lt;/li>
&lt;li>在同一个帧中的多个&lt;code>requestAnimationFrame&lt;/code>，它们的时间戳相同&lt;/li>
&lt;/ul>
&lt;h3 id="requestidlecallback">requestIdleCallback&lt;/h3>
&lt;p>由上述事件循环可知，每完成一次循环浏览器都会进行一次空闲时间的计算，而&lt;code>requestIdleCallback&lt;/code>中的回调就将在这段时间内执行。&lt;/p>
&lt;blockquote>
&lt;p>这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。&lt;/p>
&lt;p>强烈建议使用timeout选项进行必要的工作，否则可能会在触发回调之前经过几秒钟。
摘自&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">MDN&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>注意&lt;/code>：当页面无其他任务时，&lt;code>requestIdleCallback&lt;/code>执行的周期会被适当拉长，但最长只能为&lt;code>50ms&lt;/code>，以防出现&lt;code>不可预测的任务&lt;/code>（如用户输入）来临时无法及时响应可能会引起用户感知到的&lt;code>延迟&lt;/code>。&lt;/p>
&lt;p>&lt;img src="../../img/eventLoop/requestIdleCallback.png" alt="requestIdleCallback">&lt;/p>
&lt;h4 id="推荐阅读-1">推荐阅读&lt;/h4>
&lt;p>&lt;a href="https://www.cnblogs.com/coco1s/p/8029582.html">Web 动画帧率（FPS）计算&lt;/a> &lt;br>
&lt;a href="https://juejin.im/post/5c9c66075188251dab07413d">浏览器帧原理剖析&lt;/a>&lt;/p>
&lt;h3 id="fiber-架构渲染流程">Fiber 架构渲染流程&lt;/h3>
&lt;p>&lt;img src="../../img/react/reconciler.png" alt="reconciler">&lt;/p>
&lt;p>由此我们可以推断&lt;code>Fiber Reconciler&lt;/code>大致的工作原理：&lt;/p>
&lt;ul>
&lt;li>首次渲染执行，维护一个&lt;code>virtual dom&lt;/code>，节点为&lt;code>Fiber&lt;/code>数据结构，指向其他节点。&lt;/li>
&lt;li>每次事件循环进入更新，在&lt;code>Reconciliation&lt;/code>阶段，逐节点遍历，进行Diff、更新节点后，递归生成下一节点。&lt;/li>
&lt;li>如果有其他&lt;code>优先级更高&lt;/code>的任务，&lt;code>中断执行&lt;/code>将控制权交由主线程，继续事件循环，之后再重新构建该节点，直到所有节点更新完毕。&lt;/li>
&lt;li>进入&lt;code>Commit&lt;/code>阶段，将新生成的&lt;code>virtual dom&lt;/code>一次绘制到页面上。&lt;/li>
&lt;/ul>
&lt;h4 id="推荐阅读-2">推荐阅读&lt;/h4>
&lt;p>&lt;a href="https://juejin.im/post/5ecb313d6fb9a0479a800294#heading-5">[译] 深入了解 React Fiber 内部实现&lt;/a> &lt;br>
&lt;a href="https://juejin.im/post/5dadc6045188255a270a0f85#heading-9">这可能是最通俗的 React Fiber(时间分片) 打开方式&lt;/a>&lt;/p>
&lt;h2 id="关于fiber具体实现的一些问题与思考">关于Fiber具体实现的一些问题与思考&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>requestIdleCallback&lt;/code>的执行次数是可变的。如果页面正常60帧运行，其执行次数最多为60，可以保证正常绘制； &lt;br>
但如果页面空闲呢？页面在1秒内只会低帧率运行，而&lt;code>requestIdleCallback&lt;/code>的执行周期也被延长到最大&lt;code>50ms&lt;/code>，1秒内只执行20次。&lt;br>
于是React对&lt;code>requestIdleCallback&lt;/code>进行了hack，源码解析见：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/60189423">你不知道的 requestIdleCallback&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/post/5ef8a83de51d45348c1dce46#heading-7">React Fiber原理解析&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/BUPTlhuanyu/ReactNote/blob/master/README.md">对react相关代码库以及框架的源码解析&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>为什么要先&lt;code>Reconciliation&lt;/code>再&lt;code>Commit&lt;/code>？换句话说，为什么要先diff再patch？看似这里一次循环就可以执行，没必要分开进行两次。 &lt;br>
其实在旧树的基础上新生成一颗&lt;code>WIP树&lt;/code>，可以将其类比为git的分支，只有分支的功能完全实现且没有错误时，才会合并到主分支。如果有节点抛出异常，还可以&lt;code>复用旧节点&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Fiber&lt;/code>真的有用吗？&lt;code>Fiber&lt;/code>的意义在哪里？ &lt;br>
我们回想一下&lt;code>Fiber&lt;/code>架构诞生的原因是什么，为了避免在&lt;code>Reconciliation&lt;/code>(diff)的时候，调用栈&lt;code>同步执行&lt;/code>消耗大量CPU执行时间，导致&lt;code>堵塞&lt;/code>。这里存在两个问题：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Reconciliation&lt;/code>会消耗16ms以上是一个不常见的场景，甚至除非是在进行动画，否则&lt;code>100ms&lt;/code>内的延迟用户都是无感知的；&lt;/li>
&lt;li>&lt;code>Fiber&lt;/code>只是保证diff过程异步进行，但进行渲染消耗的时间任然是&lt;code>一次性&lt;/code>的、不变的。&lt;/li>
&lt;li>对于&lt;code>React&lt;/code>中或许在大应用会有一些性能优化，但大部分场景无影响，反而开发这样一个架构的工作量很大。&lt;/li>
&lt;li>而&lt;code>Vue&lt;/code>通过&lt;code>模板编译&lt;/code>和&lt;code>依赖变更&lt;/code>策略在前期优化了很多性能，这也是&lt;a href="https://github.com/vuejs/rfcs/issues/89">为什么Vue3中移除了time slicing&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Fiber&lt;/code>的异步思想我们应该很熟悉了，相比于自己开发这样一个架构，为什么不采用类似&lt;code>WebWorker&lt;/code>之类的多线程进行diff呢？这样优化不仅适应于React，对其他类似框架也同样适用。详情见：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/270573836">用web worker多核并行diff虚拟dom的操作存在哪些问题？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/facebook/react/issues/3092">https://github.com/facebook/react/issues/3092&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@azizhk/building-an-async-react-renderer-with-diffing-in-web-worker-f3be07f16d90">Building an Async React Renderer with Diffing in Web Worker&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://segmentfault.com/a/1190000021272657">为什么废弃react生命周期函数？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/42413419">谈谈 React 新的生命周期钩子&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/post/5ae6cd96f265da0b9c106931#heading-8">React v16.3 版本新生命周期函数浅析及升级方案&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.im/post/5bed21546fb9a049e93c4bac">React 重要的一次重构：认识异步渲染架构 Fiber&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>