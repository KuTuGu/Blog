<!doctype html><html lang=en><head><title>React新版本为什么要移除掉一些生命周期 :: KuTuGu的博客</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="React新版本为什么要移除掉一些生命周期？ 从上图新版本React的生命周期来看，React废弃了以下三种生命周期钩子：
 componentWillMount componentWillReceiveProps componentWillUpdate  下面我们来逐一分析它们被废弃的原因：
componentWillReceiveProps 此方法将会被getDerivedStateFromProps这一静态方法取代，通过返回一个对象来表示新的state。
看似并无区别，但使用getDerivedStateFromProps的原因在于对API的进一步解耦。 此方法是静态的，所以无法获取或者执行实例上的其他副作用函数，只专注于根据当前的nextProps来更新组件的state。
原来的componentWillReceiveProps函数内，this上的其余副作用函数可以在componentDidUpdate中进行。
一方面，React通过API规范来约束开发者，强调代码书写的规范性。 另一方面，通过将状态变化和副作用分离到Fiber架构的Reconciliation和Commit两个阶段，优化性能（详情见下文）。
componentWillMount 很多开发者喜欢在componentWillMount中获取异步数据，希望可以提早进行异步请求，尽量避免白屏。首先，这一想法不无道理，分两种情况考虑：
 立即获取数据，在第一次render之前处理完成，避免白屏 异步获取数据，第二次render进行有效绘制，与componentDidMount相比白屏时间缩短  当然，官方对于这一解释是：componentWillMount、render 和 componentDidMount 方法虽然存在调用先后顺序。 但在大多数情况下，几乎都是在很短的时间内先后执行完毕，几乎不会对用户体验产生影响。
看样子在componentWillMount似乎并无不妥之处，反而还可能会优化效率，为什么会被废除呢？主要原因有以下几点：
 对于服务器渲染（ssr），在componentWillMount内获取数据可以保证返回的页面是最终页面，但存在一个问题：客户端渲染时会再次请求，会浪费IO资源。 对于服务器渲染（ssr），在componentWillMount中绑定事件，但由于并没有后续的生命周期，导致资源无法释放，可能产生内存泄露。 客户端渲染也有可能产生上面两个问题，在Fiber架构中，componentWillMount所在的Reconciliation阶段可能被多次打断，可能产生多次网络请求或多次事件监听（详情见下文）。  componentWillUpdate componentWillUpdate也是如此：
 componentWillUpdate可能被多次打断，在这个钩子获取更新前的视图情况或执行副作用都不妥 getSnapshotBeforeUpdate是真正在视图变更前调用的，获取到组件状态信息更加可靠； 另一方面getSnapshotBeforeUpdate的返回结果可直接作为参数传入componentDidUpdate中。  Fiber核心架构 从上面三个生命周期的移除都可以看到Fiber架构的身影，下面我们就来深入了解下：
React新版本的到来，与之相应的是核心架构的替换和异步渲染概念的引入。
React框架的视图更新取决于virtual dom和diff算法，找到变化之后再将新的virtual dom渲染到不同视图(如android、pc)，这一通用的过程称为Reconciler。
旧版本的React使用的是Stack Reconciler，新版本采用的是Fiber Reconciler，因为其中任务调度处理的最小单元为Fiber数据结构：
// Fiber 基于链表结构，拥有一个个指针，指向它的父节点子节点和兄弟节点。 // 在 diff 的过程中，依照节点的链接关系进行遍历 Fiber = { &amp;#39;tag&amp;#39; // 标记任务节点类型  &amp;#39;return&amp;#39; // 父节点  &amp;#39;child&amp;#39; // 子节点  &amp;#39;sibling&amp;#39; // 兄弟节点  &amp;#39;alternate&amp;#39; // 变化记录  // ."><meta name=keywords content="React,生命周期,Fiber架构"><meta name=robots content="noodp"><link rel=canonical href=../../post/react%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A7%BB%E9%99%A4%E6%8E%89%E4%B8%80%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/><link rel=stylesheet href=../../assets/style.css><link rel=stylesheet href=../../assets/colorful.css><link rel=apple-touch-icon href=../../img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=../../img/favicon/colorful.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="React新版本为什么要移除掉一些生命周期"><meta property="og:description" content="从React移除一些生命周期的角度来看React新版本架构的迭代调整"><meta property="og:url" content="/post/react%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A7%BB%E9%99%A4%E6%8E%89%E4%B8%80%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"><meta property="og:site_name" content="KuTuGu的博客"><meta property="og:image" content="/images/react/react-lifeCycle.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-08-26 23:26:03 +0800 +0800"></head><body class=colorful><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=../../><div class=logo>主页</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=https://github.com/KuTuGu>Github</a></li><li><a href=../../about>关于</a></li><li><a href=https://kutugu.github.io/resume>简历</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=https://github.com/KuTuGu>Github</a></li><li><a href=../../about>关于</a></li><li><a href=https://kutugu.github.io/resume>简历</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=../../post/react%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A7%BB%E9%99%A4%E6%8E%89%E4%B8%80%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/>React新版本为什么要移除掉一些生命周期</a></h1><div class=post-meta><span class=post-date>2020-08-26</span>
<span class=post-author>:: KuTuGu</span></div><span class=post-tags>#<a href=../../tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/>前端框架</a>&nbsp;</span>
<img src=../../images/react/react-lifeCycle.png class=post-cover alt=React新版本为什么要移除掉一些生命周期><div class=post-content><div><h1 id=react新版本为什么要移除掉一些生命周期>React新版本为什么要移除掉一些生命周期？<a href=#react新版本为什么要移除掉一些生命周期 class=hanchor arialabel=Anchor>&#8983;</a></h1><p>从上图新版本React的生命周期来看，React废弃了以下三种生命周期钩子：</p><ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>componentWillUpdate</code></li></ul><p>下面我们来逐一分析它们被废弃的原因：</p><h2 id=componentwillreceiveprops>componentWillReceiveProps<a href=#componentwillreceiveprops class=hanchor arialabel=Anchor>&#8983;</a></h2><p>此方法将会被<code>getDerivedStateFromProps</code>这一静态方法取代，通过返回一个对象来表示新的state。</p><p>看似并无区别，但使用<code>getDerivedStateFromProps</code>的原因在于对API的进一步解耦。<br>此方法是静态的，所以无法获取或者执行实例上的其他副作用函数，只专注于根据当前的<code>nextProps</code>来更新组件的<code>state</code>。</p><p>原来的<code>componentWillReceiveProps</code>函数内，this上的其余副作用函数可以在<code>componentDidUpdate</code>中进行。</p><p>一方面，React通过API规范来约束开发者，强调代码书写的<code>规范性</code>。<br>另一方面，通过将<code>状态变化</code>和<code>副作用</code>分离到<code>Fiber</code>架构的<code>Reconciliation</code>和<code>Commit</code>两个阶段，优化性能（详情见下文）。</p><h2 id=componentwillmount>componentWillMount<a href=#componentwillmount class=hanchor arialabel=Anchor>&#8983;</a></h2><p>很多开发者喜欢在<code>componentWillMount</code>中获取异步数据，希望可以提早进行异步请求，尽量避免白屏。首先，这一想法不无道理，分两种情况考虑：</p><ul><li>立即获取数据，在第一次render之前处理完成，避免白屏</li><li>异步获取数据，第二次render进行有效绘制，与<code>componentDidMount</code>相比白屏时间缩短</li></ul><p>当然，官方对于这一解释是：<code>componentWillMount</code>、<code>render</code> 和 <code>componentDidMount</code> 方法虽然存在调用先后顺序。<br>但在大多数情况下，几乎都是在很短的时间内先后执行完毕，几乎不会对用户体验产生影响。</p><p>看样子在<code>componentWillMount</code>似乎并无不妥之处，反而还可能会优化效率，为什么会被废除呢？主要原因有以下几点：</p><ul><li>对于服务器渲染（<code>ssr</code>），在<code>componentWillMount</code>内获取数据可以保证返回的页面是最终页面，但存在一个问题：客户端渲染时会再次请求，会<code>浪费IO资源</code>。</li><li>对于服务器渲染（<code>ssr</code>），在<code>componentWillMount</code>中绑定事件，但由于并没有后续的生命周期，导致资源无法释放，可能产生<code>内存泄露</code>。</li><li>客户端渲染也有可能产生上面两个问题，在<code>Fiber</code>架构中，<code>componentWillMount</code>所在的<code>Reconciliation</code>阶段可能被多次打断，可能产生多次网络请求或多次事件监听（详情见下文）。</li></ul><h2 id=componentwillupdate>componentWillUpdate<a href=#componentwillupdate class=hanchor arialabel=Anchor>&#8983;</a></h2><p><code>componentWillUpdate</code>也是如此：</p><ul><li><code>componentWillUpdate</code>可能被多次打断，在这个钩子获取<code>更新前的视图情况</code>或执行副作用都不妥</li><li><code>getSnapshotBeforeUpdate</code>是真正在视图变更前调用的，获取到组件状态信息更加可靠；<br>另一方面<code>getSnapshotBeforeUpdate</code>的返回结果可直接作为参数传入<code>componentDidUpdate</code>中。</li></ul><h2 id=fiber核心架构>Fiber核心架构<a href=#fiber核心架构 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>从上面三个生命周期的移除都可以看到<code>Fiber</code>架构的身影，下面我们就来深入了解下：</p><p>React新版本的到来，与之相应的是<code>核心架构</code>的替换和<code>异步渲染</code>概念的引入。</p><p>React框架的视图更新取决于<code>virtual dom</code>和<a href=https://juejin.im/post/5cb5b4926fb9a068b52fb823>diff算法</a>，找到变化之后再将新的<code>virtual dom</code>渲染到不同视图(如android、pc)，这一通用的过程称为<code>Reconciler</code>。</p><p>旧版本的React使用的是<code>Stack Reconciler</code>，新版本采用的是<code>Fiber Reconciler</code>，因为其中任务调度处理的最小单元为<code>Fiber</code>数据结构：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// Fiber 基于链表结构，拥有一个个指针，指向它的父节点子节点和兄弟节点。
</span><span style=color:#75715e>// 在 diff 的过程中，依照节点的链接关系进行遍历
</span><span style=color:#75715e></span><span style=color:#a6e22e>Fiber</span> <span style=color:#f92672>=</span> {
 <span style=color:#e6db74>&#39;tag&#39;</span>       <span style=color:#75715e>// 标记任务节点类型
</span><span style=color:#75715e></span> <span style=color:#e6db74>&#39;return&#39;</span>    <span style=color:#75715e>// 父节点
</span><span style=color:#75715e></span> <span style=color:#e6db74>&#39;child&#39;</span>     <span style=color:#75715e>// 子节点
</span><span style=color:#75715e></span> <span style=color:#e6db74>&#39;sibling&#39;</span>   <span style=color:#75715e>// 兄弟节点
</span><span style=color:#75715e></span> <span style=color:#e6db74>&#39;alternate&#39;</span> <span style=color:#75715e>// 变化记录
</span><span style=color:#75715e></span> <span style=color:#75715e>// .....
</span><span style=color:#75715e></span>};
</code></pre></div><p>两者的主要区别在于：
相比于<code>Stack Reconciler</code>的递归调用渲染，虽然diff算法被React优化为<code>O(n)</code>复杂度，但对于特别庞大的dom树来说，递归调用依旧会消耗特别长的时间，在这期间任何交互都会被阻塞。</p><p><code>Fiber Reconciler</code>引入了异步渲染的概念，虽然也是根据Fiber数据结构进行链式处理，但可以将其切割为一个个小任务，异步进行处理，避免堵塞高优先级的交互等事件：</p><blockquote><p><code>Fiber</code>的出现把<code>Reconciler</code>的过程拆分成了一个个的小任务，并在完成了小任务之后暂停执行，检查是否有<code>高优先级</code>需要更新的内容和需要响应的事件，做出相应的处理后再继续执行。</p><p><code>Fiber</code>还会为不同的任务设置不同的优先级：</p><ul><li>高优先级任务是需要马上展示到页面上的，如<code>用户交互</code>、<code>动画</code>等。</li><li>低优先级的任务如<code>网络请求</code>、<code>state变更</code>等，可以在后面进行延迟处理。<br>当然React会为其指定<a href=https://www.zhihu.com/question/405268183>阈值</a>，避免长期被高优先级打断。</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>// 一些优先级划分参考如下：   
</span><span style=color:#75715e></span>{     
  <span style=color:#a6e22e>Synchronous</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>1</span>, <span style=color:#75715e>// 同步任务，优先级最高           
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>Task</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>,        <span style=color:#75715e>// 当前调度正执行的任务         
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>Animation</span> <span style=color:#ae81ff>3</span>,    <span style=color:#75715e>// 动画         
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>High</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span>,        <span style=color:#75715e>// 高优先级         
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>Low</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>5</span>,         <span style=color:#75715e>// 低优先级          
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>Offscreen</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>6</span>,   <span style=color:#75715e>// 当前屏幕外的更新，优先级最低  
</span><span style=color:#75715e></span>}    
</code></pre></div></blockquote><p><img src=../../images/react/fiber-phase.png alt=Fiber阶段></p><p>前面说了<code>Fiber</code>算法中更新是分阶段的，首先是<code>Reconciliation</code>阶段，这个阶段在diff前后<code>virtual dom</code>树的差异，耗时过长，可以打断；然后是<code>Commit</code>的阶段，这个阶段将一直把更新渲染到页面上。</p><p><code>Reconciliation</code>阶段有那些生命周期呢？没错，废除的三个生命周期赫然在列：</p><ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>componentWillUpdate</code></li><li><code>shouldComponentUpdate</code>，纯函数不会移除</li></ul><h3 id=推荐阅读>推荐阅读<a href=#推荐阅读 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><a href=https://juejin.im/post/5e1e9f33f265da3e2c247176#heading-16>零代码深入浅出React并发模式，带你理解React Fiber架构</a></p><h2 id=事件循环----fiber架构的实现原理>事件循环 &ndash; Fiber架构的实现原理<a href=#事件循环----fiber架构的实现原理 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><code>Fiber</code>架构的<code>异步渲染</code>依赖的是浏览器底层的<code>事件循环</code>。</p><p>我们知道浏览器的持续渲染页面依赖的就是事件循环机制，当页面文件解析后、脚本执行，会形成各种队列，之后就开始了页面的事件循环：</p><ul><li>各种宏任务队列（取一任务） => 微任务队列（全部执行） => 渲染（可能） => 计算空闲时间</li></ul><p>上述循环基本完成在一帧（和<code>浏览器</code>刷新率有关，一般为60HZ或者更高）内，渲染阶段根据是否有足够时间选择是否执行。</p><p>为了保证页面的流畅度，渲染帧数要保证在每秒60左右(和刷新率无关，当然高刷新率的渲染帧数一般会更高)</p><p>由上述可知，这个渲染阶段是不可控的。而之前使用<code>setTimeInterval</code>来绘制动画：</p><ul><li>一方面可能被其他任务堵塞，造成<code>延迟</code>，或者在浏览器下次重绘之前调用多次，导致<code>掉帧</code>；</li><li>另一方面固定的间隔在<code>不同刷新率</code>设备的适配上也有一定问题。</li></ul><p>于是浏览器暴露了一些接口来细粒化地控制事件循环的绘制：<code>requestAnimationFrame</code>、<code>requestIdleCallback</code>。</p><p><img src=../../images/eventLoop/frame.jpg alt=frame></p><h3 id=requestanimationframe>requestAnimationFrame<a href=#requestanimationframe class=hanchor arialabel=Anchor>&#8983;</a></h3><p>简单来说，<code>requestAnimationFrame</code>内的回调函数会在浏览器下一次重绘之前执行，完美地解决了上述<code>setTimeInterval</code>的问题，而且如果标签页被隐藏，回调也会被暂停调用以提升性能和电池寿命。</p><p>具体应用时需要注意两点：</p><ul><li><code>requestAnimationFrame</code>只会要求浏览器在<code>下一次</code>重绘之前调用指定的回调函数，连续需要递归</li><li>在同一个帧中的多个<code>requestAnimationFrame</code>，它们的时间戳相同</li></ul><h3 id=requestidlecallback>requestIdleCallback<a href=#requestidlecallback class=hanchor arialabel=Anchor>&#8983;</a></h3><p>由上述事件循环可知，每完成一次循环浏览器都会进行一次空闲时间的计算，而<code>requestIdleCallback</code>中的回调就将在这段时间内执行。</p><blockquote><p>这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。</p><p>强烈建议使用timeout选项进行必要的工作，否则可能会在触发回调之前经过几秒钟。
摘自<a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback>MDN</a></p></blockquote><p><code>注意</code>：当页面无其他任务时，<code>requestIdleCallback</code>执行的周期会被适当拉长，但最长只能为<code>50ms</code>，以防出现<code>不可预测的任务</code>（如用户输入）来临时无法及时响应可能会引起用户感知到的<code>延迟</code>。</p><p><img src=../../images/eventLoop/requestIdleCallback.png alt=requestIdleCallback></p><h4 id=推荐阅读-1>推荐阅读<a href=#推荐阅读-1 class=hanchor arialabel=Anchor>&#8983;</a></h4><p><a href=https://www.cnblogs.com/coco1s/p/8029582.html>Web 动画帧率（FPS）计算</a><br><a href=https://juejin.im/post/5c9c66075188251dab07413d>浏览器帧原理剖析</a></p><h3 id=fiber-架构渲染流程>Fiber 架构渲染流程<a href=#fiber-架构渲染流程 class=hanchor arialabel=Anchor>&#8983;</a></h3><p><img src=../../images/react/reconciler.png alt=reconciler></p><p>由此我们可以推断<code>Fiber Reconciler</code>大致的工作原理：</p><ul><li>首次渲染执行，维护一个<code>virtual dom</code>，节点为<code>Fiber</code>数据结构，指向其他节点。</li><li>每次事件循环进入更新，在<code>Reconciliation</code>阶段，逐节点遍历，进行Diff、更新节点后，递归生成下一节点。</li><li>如果有其他<code>优先级更高</code>的任务，<code>中断执行</code>将控制权交由主线程，继续事件循环，之后再重新构建该节点，直到所有节点更新完毕。</li><li>进入<code>Commit</code>阶段，将新生成的<code>virtual dom</code>一次绘制到页面上。</li></ul><h4 id=推荐阅读-2>推荐阅读<a href=#推荐阅读-2 class=hanchor arialabel=Anchor>&#8983;</a></h4><p><a href=https://juejin.im/post/5ecb313d6fb9a0479a800294#heading-5>[译] 深入了解 React Fiber 内部实现</a><br><a href=https://juejin.im/post/5dadc6045188255a270a0f85#heading-9>这可能是最通俗的 React Fiber(时间分片) 打开方式</a></p><h2 id=关于fiber具体实现的一些问题与思考>关于Fiber具体实现的一些问题与思考<a href=#关于fiber具体实现的一些问题与思考 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><p><code>requestIdleCallback</code>的执行次数是可变的。如果页面正常60帧运行，其执行次数最多为60，可以保证正常绘制；<br>但如果页面空闲呢？页面在1秒内只会低帧率运行，而<code>requestIdleCallback</code>的执行周期也被延长到最大<code>50ms</code>，1秒内只执行20次。<br>于是React对<code>requestIdleCallback</code>进行了hack，源码解析见：</p><ul><li><a href=https://zhuanlan.zhihu.com/p/60189423>你不知道的 requestIdleCallback</a></li><li><a href=https://juejin.im/post/5ef8a83de51d45348c1dce46#heading-7>React Fiber原理解析</a></li><li><a href=https://github.com/BUPTlhuanyu/ReactNote/blob/master/README.md>对react相关代码库以及框架的源码解析</a></li></ul></li><li><p>为什么要先<code>Reconciliation</code>再<code>Commit</code>？换句话说，为什么要先diff再patch？看似这里一次循环就可以执行，没必要分开进行两次。<br>其实在旧树的基础上新生成一颗<code>WIP树</code>，可以将其类比为git的分支，只有分支的功能完全实现且没有错误时，才会合并到主分支。如果有节点抛出异常，还可以<code>复用旧节点</code>。</p></li><li><p><code>Fiber</code>真的有用吗？<code>Fiber</code>的意义在哪里？<br>我们回想一下<code>Fiber</code>架构诞生的原因是什么，为了避免在<code>Reconciliation</code>(diff)的时候，调用栈<code>同步执行</code>消耗大量CPU执行时间，导致<code>堵塞</code>。这里存在两个问题：</p><ul><li><code>Reconciliation</code>会消耗16ms以上是一个不常见的场景，甚至除非是在进行动画，否则<code>100ms</code>内的延迟用户都是无感知的；</li><li><code>Fiber</code>只是保证diff过程异步进行，但进行渲染消耗的时间任然是<code>一次性</code>的、不变的。</li><li>对于<code>React</code>中或许在大应用会有一些性能优化，但大部分场景无影响，反而开发这样一个架构的工作量很大。</li><li>而<code>Vue</code>通过<code>模板编译</code>和<code>依赖变更</code>策略在前期优化了很多性能，这也是<a href=https://github.com/vuejs/rfcs/issues/89>为什么Vue3中移除了time slicing</a></li></ul></li><li><p><code>Fiber</code>的异步思想我们应该很熟悉了，相比于自己开发这样一个架构，为什么不采用类似<code>WebWorker</code>之类的多线程进行diff呢？这样优化不仅适应于React，对其他类似框架也同样适用。详情见：</p><ul><li><a href=https://www.zhihu.com/question/270573836>用web worker多核并行diff虚拟dom的操作存在哪些问题？</a></li><li><a href=https://github.com/facebook/react/issues/3092>https://github.com/facebook/react/issues/3092</a></li><li><a href=https://medium.com/@azizhk/building-an-async-react-renderer-with-diffing-in-web-worker-f3be07f16d90>Building an Async React Renderer with Diffing in Web Worker</a></li></ul></li></ul><h2 id=参考>参考<a href=#参考 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><a href=https://segmentfault.com/a/1190000021272657>为什么废弃react生命周期函数？</a></li><li><a href=https://zhuanlan.zhihu.com/p/42413419>谈谈 React 新的生命周期钩子</a></li><li><a href=https://juejin.im/post/5ae6cd96f265da0b9c106931#heading-8>React v16.3 版本新生命周期函数浅析及升级方案</a></li><li><a href=https://juejin.im/post/5bed21546fb9a049e93c4bac>React 重要的一次重构：认识异步渲染架构 Fiber</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>阅读其它文章</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=../../post/%E5%89%8D%E7%AB%AF%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E5%B0%8F%E7%BB%93/><span class=button__icon>←</span>
<span class=button__text>前端日志工具小结</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2020 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=../../assets/main.js></script><script src=../../assets/prism.js></script></div></body></html>